/*
 * OpenAI API
 * The OpenAI REST API. Please see https://platform.openai.com/docs/api-reference for more details.
 *
 * The version of the OpenAPI document: 2.3.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package com.openai.openapi.model;

import java.util.Objects;
import java.util.Arrays;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonTypeName;
import com.fasterxml.jackson.annotation.JsonValue;
import com.openai.openapi.model.AssistantObjectResponseFormat;
import com.openai.openapi.model.CreateRunRequestToolChoice;
import com.openai.openapi.model.CreateRunRequestTruncationStrategy;
import com.openai.openapi.model.CreateThreadAndRunRequestModel;
import com.openai.openapi.model.CreateThreadAndRunRequestToolResources;
import com.openai.openapi.model.CreateThreadAndRunRequestToolsInner;
import com.openai.openapi.model.CreateThreadRequest;
import java.math.BigDecimal;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import org.openapitools.jackson.nullable.JsonNullable;
import com.fasterxml.jackson.annotation.JsonIgnore;
import org.openapitools.jackson.nullable.JsonNullable;
import java.util.NoSuchElementException;
import com.fasterxml.jackson.annotation.JsonPropertyOrder;
import com.fasterxml.jackson.annotation.JsonTypeName;
import java.io.UnsupportedEncodingException;
import java.net.URLEncoder;
import java.util.StringJoiner;

/**
 * CreateThreadAndRunRequest
 */
@JsonPropertyOrder({
  CreateThreadAndRunRequest.JSON_PROPERTY_ASSISTANT_ID,
  CreateThreadAndRunRequest.JSON_PROPERTY_THREAD,
  CreateThreadAndRunRequest.JSON_PROPERTY_MODEL,
  CreateThreadAndRunRequest.JSON_PROPERTY_INSTRUCTIONS,
  CreateThreadAndRunRequest.JSON_PROPERTY_TOOLS,
  CreateThreadAndRunRequest.JSON_PROPERTY_TOOL_RESOURCES,
  CreateThreadAndRunRequest.JSON_PROPERTY_METADATA,
  CreateThreadAndRunRequest.JSON_PROPERTY_TEMPERATURE,
  CreateThreadAndRunRequest.JSON_PROPERTY_TOP_P,
  CreateThreadAndRunRequest.JSON_PROPERTY_STREAM,
  CreateThreadAndRunRequest.JSON_PROPERTY_MAX_PROMPT_TOKENS,
  CreateThreadAndRunRequest.JSON_PROPERTY_MAX_COMPLETION_TOKENS,
  CreateThreadAndRunRequest.JSON_PROPERTY_TRUNCATION_STRATEGY,
  CreateThreadAndRunRequest.JSON_PROPERTY_TOOL_CHOICE,
  CreateThreadAndRunRequest.JSON_PROPERTY_PARALLEL_TOOL_CALLS,
  CreateThreadAndRunRequest.JSON_PROPERTY_RESPONSE_FORMAT
})
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2025-02-28T10:23:25.420936454-05:00[US/Eastern]", comments = "Generator version: 7.11.0")
public class CreateThreadAndRunRequest {
  public static final String JSON_PROPERTY_ASSISTANT_ID = "assistant_id";
  @javax.annotation.Nonnull
  private String assistantId;

  public static final String JSON_PROPERTY_THREAD = "thread";
  @javax.annotation.Nullable
  private CreateThreadRequest thread;

  public static final String JSON_PROPERTY_MODEL = "model";
  @javax.annotation.Nullable
  private JsonNullable<CreateThreadAndRunRequestModel> model = JsonNullable.<CreateThreadAndRunRequestModel>undefined();

  public static final String JSON_PROPERTY_INSTRUCTIONS = "instructions";
  @javax.annotation.Nullable
  private JsonNullable<String> instructions = JsonNullable.<String>undefined();

  public static final String JSON_PROPERTY_TOOLS = "tools";
  @javax.annotation.Nullable
  private JsonNullable<List<CreateThreadAndRunRequestToolsInner>> tools = JsonNullable.<List<CreateThreadAndRunRequestToolsInner>>undefined();

  public static final String JSON_PROPERTY_TOOL_RESOURCES = "tool_resources";
  @javax.annotation.Nullable
  private JsonNullable<CreateThreadAndRunRequestToolResources> toolResources = JsonNullable.<CreateThreadAndRunRequestToolResources>undefined();

  public static final String JSON_PROPERTY_METADATA = "metadata";
  @javax.annotation.Nullable
  private JsonNullable<Map<String, String>> metadata = JsonNullable.<Map<String, String>>undefined();

  public static final String JSON_PROPERTY_TEMPERATURE = "temperature";
  @javax.annotation.Nullable
  private JsonNullable<BigDecimal> temperature = JsonNullable.<BigDecimal>of(new BigDecimal("1"));

  public static final String JSON_PROPERTY_TOP_P = "top_p";
  @javax.annotation.Nullable
  private JsonNullable<BigDecimal> topP = JsonNullable.<BigDecimal>of(new BigDecimal("1"));

  public static final String JSON_PROPERTY_STREAM = "stream";
  @javax.annotation.Nullable
  private JsonNullable<Boolean> stream = JsonNullable.<Boolean>undefined();

  public static final String JSON_PROPERTY_MAX_PROMPT_TOKENS = "max_prompt_tokens";
  @javax.annotation.Nullable
  private JsonNullable<Integer> maxPromptTokens = JsonNullable.<Integer>undefined();

  public static final String JSON_PROPERTY_MAX_COMPLETION_TOKENS = "max_completion_tokens";
  @javax.annotation.Nullable
  private JsonNullable<Integer> maxCompletionTokens = JsonNullable.<Integer>undefined();

  public static final String JSON_PROPERTY_TRUNCATION_STRATEGY = "truncation_strategy";
  @javax.annotation.Nullable
  private CreateRunRequestTruncationStrategy truncationStrategy;

  public static final String JSON_PROPERTY_TOOL_CHOICE = "tool_choice";
  @javax.annotation.Nullable
  private CreateRunRequestToolChoice toolChoice;

  public static final String JSON_PROPERTY_PARALLEL_TOOL_CALLS = "parallel_tool_calls";
  @javax.annotation.Nullable
  private Boolean parallelToolCalls = true;

  public static final String JSON_PROPERTY_RESPONSE_FORMAT = "response_format";
  @javax.annotation.Nullable
  private AssistantObjectResponseFormat responseFormat;

  public CreateThreadAndRunRequest() {
  }

  public CreateThreadAndRunRequest assistantId(@javax.annotation.Nonnull String assistantId) {
    
    this.assistantId = assistantId;
    return this;
  }

  /**
   * The ID of the [assistant](/docs/api-reference/assistants) to use to execute this run.
   * @return assistantId
   */
  @javax.annotation.Nonnull
  @JsonProperty(JSON_PROPERTY_ASSISTANT_ID)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)

  public String getAssistantId() {
    return assistantId;
  }


  @JsonProperty(JSON_PROPERTY_ASSISTANT_ID)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public void setAssistantId(@javax.annotation.Nonnull String assistantId) {
    this.assistantId = assistantId;
  }

  public CreateThreadAndRunRequest thread(@javax.annotation.Nullable CreateThreadRequest thread) {
    
    this.thread = thread;
    return this;
  }

  /**
   * Get thread
   * @return thread
   */
  @javax.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_THREAD)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public CreateThreadRequest getThread() {
    return thread;
  }


  @JsonProperty(JSON_PROPERTY_THREAD)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setThread(@javax.annotation.Nullable CreateThreadRequest thread) {
    this.thread = thread;
  }

  public CreateThreadAndRunRequest model(@javax.annotation.Nullable CreateThreadAndRunRequestModel model) {
    this.model = JsonNullable.<CreateThreadAndRunRequestModel>of(model);
    
    return this;
  }

  /**
   * Get model
   * @return model
   */
  @javax.annotation.Nullable
  @JsonIgnore

  public CreateThreadAndRunRequestModel getModel() {
        return model.orElse(null);
  }

  @JsonProperty(JSON_PROPERTY_MODEL)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public JsonNullable<CreateThreadAndRunRequestModel> getModel_JsonNullable() {
    return model;
  }
  
  @JsonProperty(JSON_PROPERTY_MODEL)
  public void setModel_JsonNullable(JsonNullable<CreateThreadAndRunRequestModel> model) {
    this.model = model;
  }

  public void setModel(@javax.annotation.Nullable CreateThreadAndRunRequestModel model) {
    this.model = JsonNullable.<CreateThreadAndRunRequestModel>of(model);
  }

  public CreateThreadAndRunRequest instructions(@javax.annotation.Nullable String instructions) {
    this.instructions = JsonNullable.<String>of(instructions);
    
    return this;
  }

  /**
   * Override the default system message of the assistant. This is useful for modifying the behavior on a per-run basis.
   * @return instructions
   */
  @javax.annotation.Nullable
  @JsonIgnore

  public String getInstructions() {
        return instructions.orElse(null);
  }

  @JsonProperty(JSON_PROPERTY_INSTRUCTIONS)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public JsonNullable<String> getInstructions_JsonNullable() {
    return instructions;
  }
  
  @JsonProperty(JSON_PROPERTY_INSTRUCTIONS)
  public void setInstructions_JsonNullable(JsonNullable<String> instructions) {
    this.instructions = instructions;
  }

  public void setInstructions(@javax.annotation.Nullable String instructions) {
    this.instructions = JsonNullable.<String>of(instructions);
  }

  public CreateThreadAndRunRequest tools(@javax.annotation.Nullable List<CreateThreadAndRunRequestToolsInner> tools) {
    this.tools = JsonNullable.<List<CreateThreadAndRunRequestToolsInner>>of(tools);
    
    return this;
  }

  public CreateThreadAndRunRequest addToolsItem(CreateThreadAndRunRequestToolsInner toolsItem) {
    if (this.tools == null || !this.tools.isPresent()) {
      this.tools = JsonNullable.<List<CreateThreadAndRunRequestToolsInner>>of(new ArrayList<>());
    }
    try {
      this.tools.get().add(toolsItem);
    } catch (java.util.NoSuchElementException e) {
      // this can never happen, as we make sure above that the value is present
    }
    return this;
  }

  /**
   * Override the tools the assistant can use for this run. This is useful for modifying the behavior on a per-run basis.
   * @return tools
   */
  @javax.annotation.Nullable
  @JsonIgnore

  public List<CreateThreadAndRunRequestToolsInner> getTools() {
        return tools.orElse(null);
  }

  @JsonProperty(JSON_PROPERTY_TOOLS)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public JsonNullable<List<CreateThreadAndRunRequestToolsInner>> getTools_JsonNullable() {
    return tools;
  }
  
  @JsonProperty(JSON_PROPERTY_TOOLS)
  public void setTools_JsonNullable(JsonNullable<List<CreateThreadAndRunRequestToolsInner>> tools) {
    this.tools = tools;
  }

  public void setTools(@javax.annotation.Nullable List<CreateThreadAndRunRequestToolsInner> tools) {
    this.tools = JsonNullable.<List<CreateThreadAndRunRequestToolsInner>>of(tools);
  }

  public CreateThreadAndRunRequest toolResources(@javax.annotation.Nullable CreateThreadAndRunRequestToolResources toolResources) {
    this.toolResources = JsonNullable.<CreateThreadAndRunRequestToolResources>of(toolResources);
    
    return this;
  }

  /**
   * Get toolResources
   * @return toolResources
   */
  @javax.annotation.Nullable
  @JsonIgnore

  public CreateThreadAndRunRequestToolResources getToolResources() {
        return toolResources.orElse(null);
  }

  @JsonProperty(JSON_PROPERTY_TOOL_RESOURCES)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public JsonNullable<CreateThreadAndRunRequestToolResources> getToolResources_JsonNullable() {
    return toolResources;
  }
  
  @JsonProperty(JSON_PROPERTY_TOOL_RESOURCES)
  public void setToolResources_JsonNullable(JsonNullable<CreateThreadAndRunRequestToolResources> toolResources) {
    this.toolResources = toolResources;
  }

  public void setToolResources(@javax.annotation.Nullable CreateThreadAndRunRequestToolResources toolResources) {
    this.toolResources = JsonNullable.<CreateThreadAndRunRequestToolResources>of(toolResources);
  }

  public CreateThreadAndRunRequest metadata(@javax.annotation.Nullable Map<String, String> metadata) {
    this.metadata = JsonNullable.<Map<String, String>>of(metadata);
    
    return this;
  }

  public CreateThreadAndRunRequest putMetadataItem(String key, String metadataItem) {
    if (this.metadata == null || !this.metadata.isPresent()) {
      this.metadata = JsonNullable.<Map<String, String>>of(new HashMap<>());
    }
    try {
      this.metadata.get().put(key, metadataItem);
    } catch (java.util.NoSuchElementException e) {
      // this can never happen, as we make sure above that the value is present
    }
    return this;
  }

  /**
   * Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format, and querying for objects via API or the dashboard.  Keys are strings with a maximum length of 64 characters. Values are strings with a maximum length of 512 characters. 
   * @return metadata
   */
  @javax.annotation.Nullable
  @JsonIgnore

  public Map<String, String> getMetadata() {
        return metadata.orElse(null);
  }

  @JsonProperty(JSON_PROPERTY_METADATA)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public JsonNullable<Map<String, String>> getMetadata_JsonNullable() {
    return metadata;
  }
  
  @JsonProperty(JSON_PROPERTY_METADATA)
  public void setMetadata_JsonNullable(JsonNullable<Map<String, String>> metadata) {
    this.metadata = metadata;
  }

  public void setMetadata(@javax.annotation.Nullable Map<String, String> metadata) {
    this.metadata = JsonNullable.<Map<String, String>>of(metadata);
  }

  public CreateThreadAndRunRequest temperature(@javax.annotation.Nullable BigDecimal temperature) {
    this.temperature = JsonNullable.<BigDecimal>of(temperature);
    
    return this;
  }

  /**
   * What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic. 
   * minimum: 0
   * maximum: 2
   * @return temperature
   */
  @javax.annotation.Nullable
  @JsonIgnore

  public BigDecimal getTemperature() {
        return temperature.orElse(null);
  }

  @JsonProperty(JSON_PROPERTY_TEMPERATURE)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public JsonNullable<BigDecimal> getTemperature_JsonNullable() {
    return temperature;
  }
  
  @JsonProperty(JSON_PROPERTY_TEMPERATURE)
  public void setTemperature_JsonNullable(JsonNullable<BigDecimal> temperature) {
    this.temperature = temperature;
  }

  public void setTemperature(@javax.annotation.Nullable BigDecimal temperature) {
    this.temperature = JsonNullable.<BigDecimal>of(temperature);
  }

  public CreateThreadAndRunRequest topP(@javax.annotation.Nullable BigDecimal topP) {
    this.topP = JsonNullable.<BigDecimal>of(topP);
    
    return this;
  }

  /**
   * An alternative to sampling with temperature, called nucleus sampling, where the model considers the results of the tokens with top_p probability mass. So 0.1 means only the tokens comprising the top 10% probability mass are considered.  We generally recommend altering this or temperature but not both. 
   * minimum: 0
   * maximum: 1
   * @return topP
   */
  @javax.annotation.Nullable
  @JsonIgnore

  public BigDecimal getTopP() {
        return topP.orElse(null);
  }

  @JsonProperty(JSON_PROPERTY_TOP_P)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public JsonNullable<BigDecimal> getTopP_JsonNullable() {
    return topP;
  }
  
  @JsonProperty(JSON_PROPERTY_TOP_P)
  public void setTopP_JsonNullable(JsonNullable<BigDecimal> topP) {
    this.topP = topP;
  }

  public void setTopP(@javax.annotation.Nullable BigDecimal topP) {
    this.topP = JsonNullable.<BigDecimal>of(topP);
  }

  public CreateThreadAndRunRequest stream(@javax.annotation.Nullable Boolean stream) {
    this.stream = JsonNullable.<Boolean>of(stream);
    
    return this;
  }

  /**
   * If &#x60;true&#x60;, returns a stream of events that happen during the Run as server-sent events, terminating when the Run enters a terminal state with a &#x60;data: [DONE]&#x60; message. 
   * @return stream
   */
  @javax.annotation.Nullable
  @JsonIgnore

  public Boolean getStream() {
        return stream.orElse(null);
  }

  @JsonProperty(JSON_PROPERTY_STREAM)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public JsonNullable<Boolean> getStream_JsonNullable() {
    return stream;
  }
  
  @JsonProperty(JSON_PROPERTY_STREAM)
  public void setStream_JsonNullable(JsonNullable<Boolean> stream) {
    this.stream = stream;
  }

  public void setStream(@javax.annotation.Nullable Boolean stream) {
    this.stream = JsonNullable.<Boolean>of(stream);
  }

  public CreateThreadAndRunRequest maxPromptTokens(@javax.annotation.Nullable Integer maxPromptTokens) {
    this.maxPromptTokens = JsonNullable.<Integer>of(maxPromptTokens);
    
    return this;
  }

  /**
   * The maximum number of prompt tokens that may be used over the course of the run. The run will make a best effort to use only the number of prompt tokens specified, across multiple turns of the run. If the run exceeds the number of prompt tokens specified, the run will end with status &#x60;incomplete&#x60;. See &#x60;incomplete_details&#x60; for more info. 
   * minimum: 256
   * @return maxPromptTokens
   */
  @javax.annotation.Nullable
  @JsonIgnore

  public Integer getMaxPromptTokens() {
        return maxPromptTokens.orElse(null);
  }

  @JsonProperty(JSON_PROPERTY_MAX_PROMPT_TOKENS)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public JsonNullable<Integer> getMaxPromptTokens_JsonNullable() {
    return maxPromptTokens;
  }
  
  @JsonProperty(JSON_PROPERTY_MAX_PROMPT_TOKENS)
  public void setMaxPromptTokens_JsonNullable(JsonNullable<Integer> maxPromptTokens) {
    this.maxPromptTokens = maxPromptTokens;
  }

  public void setMaxPromptTokens(@javax.annotation.Nullable Integer maxPromptTokens) {
    this.maxPromptTokens = JsonNullable.<Integer>of(maxPromptTokens);
  }

  public CreateThreadAndRunRequest maxCompletionTokens(@javax.annotation.Nullable Integer maxCompletionTokens) {
    this.maxCompletionTokens = JsonNullable.<Integer>of(maxCompletionTokens);
    
    return this;
  }

  /**
   * The maximum number of completion tokens that may be used over the course of the run. The run will make a best effort to use only the number of completion tokens specified, across multiple turns of the run. If the run exceeds the number of completion tokens specified, the run will end with status &#x60;incomplete&#x60;. See &#x60;incomplete_details&#x60; for more info. 
   * minimum: 256
   * @return maxCompletionTokens
   */
  @javax.annotation.Nullable
  @JsonIgnore

  public Integer getMaxCompletionTokens() {
        return maxCompletionTokens.orElse(null);
  }

  @JsonProperty(JSON_PROPERTY_MAX_COMPLETION_TOKENS)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public JsonNullable<Integer> getMaxCompletionTokens_JsonNullable() {
    return maxCompletionTokens;
  }
  
  @JsonProperty(JSON_PROPERTY_MAX_COMPLETION_TOKENS)
  public void setMaxCompletionTokens_JsonNullable(JsonNullable<Integer> maxCompletionTokens) {
    this.maxCompletionTokens = maxCompletionTokens;
  }

  public void setMaxCompletionTokens(@javax.annotation.Nullable Integer maxCompletionTokens) {
    this.maxCompletionTokens = JsonNullable.<Integer>of(maxCompletionTokens);
  }

  public CreateThreadAndRunRequest truncationStrategy(@javax.annotation.Nullable CreateRunRequestTruncationStrategy truncationStrategy) {
    
    this.truncationStrategy = truncationStrategy;
    return this;
  }

  /**
   * Get truncationStrategy
   * @return truncationStrategy
   */
  @javax.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_TRUNCATION_STRATEGY)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public CreateRunRequestTruncationStrategy getTruncationStrategy() {
    return truncationStrategy;
  }


  @JsonProperty(JSON_PROPERTY_TRUNCATION_STRATEGY)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setTruncationStrategy(@javax.annotation.Nullable CreateRunRequestTruncationStrategy truncationStrategy) {
    this.truncationStrategy = truncationStrategy;
  }

  public CreateThreadAndRunRequest toolChoice(@javax.annotation.Nullable CreateRunRequestToolChoice toolChoice) {
    
    this.toolChoice = toolChoice;
    return this;
  }

  /**
   * Get toolChoice
   * @return toolChoice
   */
  @javax.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_TOOL_CHOICE)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public CreateRunRequestToolChoice getToolChoice() {
    return toolChoice;
  }


  @JsonProperty(JSON_PROPERTY_TOOL_CHOICE)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setToolChoice(@javax.annotation.Nullable CreateRunRequestToolChoice toolChoice) {
    this.toolChoice = toolChoice;
  }

  public CreateThreadAndRunRequest parallelToolCalls(@javax.annotation.Nullable Boolean parallelToolCalls) {
    
    this.parallelToolCalls = parallelToolCalls;
    return this;
  }

  /**
   * Whether to enable [parallel function calling](/docs/guides/function-calling#configuring-parallel-function-calling) during tool use.
   * @return parallelToolCalls
   */
  @javax.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_PARALLEL_TOOL_CALLS)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public Boolean getParallelToolCalls() {
    return parallelToolCalls;
  }


  @JsonProperty(JSON_PROPERTY_PARALLEL_TOOL_CALLS)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setParallelToolCalls(@javax.annotation.Nullable Boolean parallelToolCalls) {
    this.parallelToolCalls = parallelToolCalls;
  }

  public CreateThreadAndRunRequest responseFormat(@javax.annotation.Nullable AssistantObjectResponseFormat responseFormat) {
    
    this.responseFormat = responseFormat;
    return this;
  }

  /**
   * Get responseFormat
   * @return responseFormat
   */
  @javax.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_RESPONSE_FORMAT)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public AssistantObjectResponseFormat getResponseFormat() {
    return responseFormat;
  }


  @JsonProperty(JSON_PROPERTY_RESPONSE_FORMAT)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setResponseFormat(@javax.annotation.Nullable AssistantObjectResponseFormat responseFormat) {
    this.responseFormat = responseFormat;
  }

  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    CreateThreadAndRunRequest createThreadAndRunRequest = (CreateThreadAndRunRequest) o;
    return Objects.equals(this.assistantId, createThreadAndRunRequest.assistantId) &&
        Objects.equals(this.thread, createThreadAndRunRequest.thread) &&
        equalsNullable(this.model, createThreadAndRunRequest.model) &&
        equalsNullable(this.instructions, createThreadAndRunRequest.instructions) &&
        equalsNullable(this.tools, createThreadAndRunRequest.tools) &&
        equalsNullable(this.toolResources, createThreadAndRunRequest.toolResources) &&
        equalsNullable(this.metadata, createThreadAndRunRequest.metadata) &&
        equalsNullable(this.temperature, createThreadAndRunRequest.temperature) &&
        equalsNullable(this.topP, createThreadAndRunRequest.topP) &&
        equalsNullable(this.stream, createThreadAndRunRequest.stream) &&
        equalsNullable(this.maxPromptTokens, createThreadAndRunRequest.maxPromptTokens) &&
        equalsNullable(this.maxCompletionTokens, createThreadAndRunRequest.maxCompletionTokens) &&
        Objects.equals(this.truncationStrategy, createThreadAndRunRequest.truncationStrategy) &&
        Objects.equals(this.toolChoice, createThreadAndRunRequest.toolChoice) &&
        Objects.equals(this.parallelToolCalls, createThreadAndRunRequest.parallelToolCalls) &&
        Objects.equals(this.responseFormat, createThreadAndRunRequest.responseFormat);
  }

  private static <T> boolean equalsNullable(JsonNullable<T> a, JsonNullable<T> b) {
    return a == b || (a != null && b != null && a.isPresent() && b.isPresent() && Objects.deepEquals(a.get(), b.get()));
  }

  @Override
  public int hashCode() {
    return Objects.hash(assistantId, thread, hashCodeNullable(model), hashCodeNullable(instructions), hashCodeNullable(tools), hashCodeNullable(toolResources), hashCodeNullable(metadata), hashCodeNullable(temperature), hashCodeNullable(topP), hashCodeNullable(stream), hashCodeNullable(maxPromptTokens), hashCodeNullable(maxCompletionTokens), truncationStrategy, toolChoice, parallelToolCalls, responseFormat);
  }

  private static <T> int hashCodeNullable(JsonNullable<T> a) {
    if (a == null) {
      return 1;
    }
    return a.isPresent() ? Arrays.deepHashCode(new Object[]{a.get()}) : 31;
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class CreateThreadAndRunRequest {\n");
    sb.append("    assistantId: ").append(toIndentedString(assistantId)).append("\n");
    sb.append("    thread: ").append(toIndentedString(thread)).append("\n");
    sb.append("    model: ").append(toIndentedString(model)).append("\n");
    sb.append("    instructions: ").append(toIndentedString(instructions)).append("\n");
    sb.append("    tools: ").append(toIndentedString(tools)).append("\n");
    sb.append("    toolResources: ").append(toIndentedString(toolResources)).append("\n");
    sb.append("    metadata: ").append(toIndentedString(metadata)).append("\n");
    sb.append("    temperature: ").append(toIndentedString(temperature)).append("\n");
    sb.append("    topP: ").append(toIndentedString(topP)).append("\n");
    sb.append("    stream: ").append(toIndentedString(stream)).append("\n");
    sb.append("    maxPromptTokens: ").append(toIndentedString(maxPromptTokens)).append("\n");
    sb.append("    maxCompletionTokens: ").append(toIndentedString(maxCompletionTokens)).append("\n");
    sb.append("    truncationStrategy: ").append(toIndentedString(truncationStrategy)).append("\n");
    sb.append("    toolChoice: ").append(toIndentedString(toolChoice)).append("\n");
    sb.append("    parallelToolCalls: ").append(toIndentedString(parallelToolCalls)).append("\n");
    sb.append("    responseFormat: ").append(toIndentedString(responseFormat)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

  /**
   * Convert the instance into URL query string.
   *
   * @return URL query string
   */
  public String toUrlQueryString() {
    return toUrlQueryString(null);
  }

  /**
   * Convert the instance into URL query string.
   *
   * @param prefix prefix of the query string
   * @return URL query string
   */
  public String toUrlQueryString(String prefix) {
    String suffix = "";
    String containerSuffix = "";
    String containerPrefix = "";
    if (prefix == null) {
      // style=form, explode=true, e.g. /pet?name=cat&type=manx
      prefix = "";
    } else {
      // deepObject style e.g. /pet?id[name]=cat&id[type]=manx
      prefix = prefix + "[";
      suffix = "]";
      containerSuffix = "]";
      containerPrefix = "[";
    }

    StringJoiner joiner = new StringJoiner("&");

    // add `assistant_id` to the URL query string
    if (getAssistantId() != null) {
      try {
        joiner.add(String.format("%sassistant_id%s=%s", prefix, suffix, URLEncoder.encode(String.valueOf(getAssistantId()), "UTF-8").replaceAll("\\+", "%20")));
      } catch (UnsupportedEncodingException e) {
        // Should never happen, UTF-8 is always supported
        throw new RuntimeException(e);
      }
    }

    // add `thread` to the URL query string
    if (getThread() != null) {
      joiner.add(getThread().toUrlQueryString(prefix + "thread" + suffix));
    }

    // add `model` to the URL query string
    if (getModel() != null) {
      joiner.add(getModel().toUrlQueryString(prefix + "model" + suffix));
    }

    // add `instructions` to the URL query string
    if (getInstructions() != null) {
      try {
        joiner.add(String.format("%sinstructions%s=%s", prefix, suffix, URLEncoder.encode(String.valueOf(getInstructions()), "UTF-8").replaceAll("\\+", "%20")));
      } catch (UnsupportedEncodingException e) {
        // Should never happen, UTF-8 is always supported
        throw new RuntimeException(e);
      }
    }

    // add `tools` to the URL query string
    if (getTools() != null) {
      for (int i = 0; i < getTools().size(); i++) {
        if (getTools().get(i) != null) {
          joiner.add(getTools().get(i).toUrlQueryString(String.format("%stools%s%s", prefix, suffix,
              "".equals(suffix) ? "" : String.format("%s%d%s", containerPrefix, i, containerSuffix))));
        }
      }
    }

    // add `tool_resources` to the URL query string
    if (getToolResources() != null) {
      joiner.add(getToolResources().toUrlQueryString(prefix + "tool_resources" + suffix));
    }

    // add `metadata` to the URL query string
    if (getMetadata() != null) {
      for (String _key : getMetadata().keySet()) {
        try {
          joiner.add(String.format("%smetadata%s%s=%s", prefix, suffix,
              "".equals(suffix) ? "" : String.format("%s%d%s", containerPrefix, _key, containerSuffix),
              getMetadata().get(_key), URLEncoder.encode(String.valueOf(getMetadata().get(_key)), "UTF-8").replaceAll("\\+", "%20")));
        } catch (UnsupportedEncodingException e) {
          // Should never happen, UTF-8 is always supported
          throw new RuntimeException(e);
        }
      }
    }

    // add `temperature` to the URL query string
    if (getTemperature() != null) {
      try {
        joiner.add(String.format("%stemperature%s=%s", prefix, suffix, URLEncoder.encode(String.valueOf(getTemperature()), "UTF-8").replaceAll("\\+", "%20")));
      } catch (UnsupportedEncodingException e) {
        // Should never happen, UTF-8 is always supported
        throw new RuntimeException(e);
      }
    }

    // add `top_p` to the URL query string
    if (getTopP() != null) {
      try {
        joiner.add(String.format("%stop_p%s=%s", prefix, suffix, URLEncoder.encode(String.valueOf(getTopP()), "UTF-8").replaceAll("\\+", "%20")));
      } catch (UnsupportedEncodingException e) {
        // Should never happen, UTF-8 is always supported
        throw new RuntimeException(e);
      }
    }

    // add `stream` to the URL query string
    if (getStream() != null) {
      try {
        joiner.add(String.format("%sstream%s=%s", prefix, suffix, URLEncoder.encode(String.valueOf(getStream()), "UTF-8").replaceAll("\\+", "%20")));
      } catch (UnsupportedEncodingException e) {
        // Should never happen, UTF-8 is always supported
        throw new RuntimeException(e);
      }
    }

    // add `max_prompt_tokens` to the URL query string
    if (getMaxPromptTokens() != null) {
      try {
        joiner.add(String.format("%smax_prompt_tokens%s=%s", prefix, suffix, URLEncoder.encode(String.valueOf(getMaxPromptTokens()), "UTF-8").replaceAll("\\+", "%20")));
      } catch (UnsupportedEncodingException e) {
        // Should never happen, UTF-8 is always supported
        throw new RuntimeException(e);
      }
    }

    // add `max_completion_tokens` to the URL query string
    if (getMaxCompletionTokens() != null) {
      try {
        joiner.add(String.format("%smax_completion_tokens%s=%s", prefix, suffix, URLEncoder.encode(String.valueOf(getMaxCompletionTokens()), "UTF-8").replaceAll("\\+", "%20")));
      } catch (UnsupportedEncodingException e) {
        // Should never happen, UTF-8 is always supported
        throw new RuntimeException(e);
      }
    }

    // add `truncation_strategy` to the URL query string
    if (getTruncationStrategy() != null) {
      joiner.add(getTruncationStrategy().toUrlQueryString(prefix + "truncation_strategy" + suffix));
    }

    // add `tool_choice` to the URL query string
    if (getToolChoice() != null) {
      joiner.add(getToolChoice().toUrlQueryString(prefix + "tool_choice" + suffix));
    }

    // add `parallel_tool_calls` to the URL query string
    if (getParallelToolCalls() != null) {
      try {
        joiner.add(String.format("%sparallel_tool_calls%s=%s", prefix, suffix, URLEncoder.encode(String.valueOf(getParallelToolCalls()), "UTF-8").replaceAll("\\+", "%20")));
      } catch (UnsupportedEncodingException e) {
        // Should never happen, UTF-8 is always supported
        throw new RuntimeException(e);
      }
    }

    // add `response_format` to the URL query string
    if (getResponseFormat() != null) {
      joiner.add(getResponseFormat().toUrlQueryString(prefix + "response_format" + suffix));
    }

    return joiner.toString();
  }

}


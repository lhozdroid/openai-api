/*
 * OpenAI API
 * The OpenAI REST API. Please see https://platform.openai.com/docs/api-reference for more details.
 *
 * The version of the OpenAPI document: 2.3.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import java.util.Arrays;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonTypeName;
import com.fasterxml.jackson.annotation.JsonValue;
import com.fasterxml.jackson.annotation.JsonPropertyOrder;
import com.fasterxml.jackson.annotation.JsonTypeName;
import java.io.UnsupportedEncodingException;
import java.net.URLEncoder;
import java.util.StringJoiner;

/**
 * Breakdown of tokens used in a completion.
 */
@JsonPropertyOrder({
  CompletionUsageCompletionTokensDetails.JSON_PROPERTY_ACCEPTED_PREDICTION_TOKENS,
  CompletionUsageCompletionTokensDetails.JSON_PROPERTY_AUDIO_TOKENS,
  CompletionUsageCompletionTokensDetails.JSON_PROPERTY_REASONING_TOKENS,
  CompletionUsageCompletionTokensDetails.JSON_PROPERTY_REJECTED_PREDICTION_TOKENS
})
@JsonTypeName("CompletionUsage_completion_tokens_details")
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2025-01-14T12:15:51.997600814-05:00[US/Eastern]", comments = "Generator version: 7.10.0")
public class CompletionUsageCompletionTokensDetails {
  public static final String JSON_PROPERTY_ACCEPTED_PREDICTION_TOKENS = "accepted_prediction_tokens";
  @javax.annotation.Nullable
  private Integer acceptedPredictionTokens;

  public static final String JSON_PROPERTY_AUDIO_TOKENS = "audio_tokens";
  @javax.annotation.Nullable
  private Integer audioTokens;

  public static final String JSON_PROPERTY_REASONING_TOKENS = "reasoning_tokens";
  @javax.annotation.Nullable
  private Integer reasoningTokens;

  public static final String JSON_PROPERTY_REJECTED_PREDICTION_TOKENS = "rejected_prediction_tokens";
  @javax.annotation.Nullable
  private Integer rejectedPredictionTokens;

  public CompletionUsageCompletionTokensDetails() {
  }

  public CompletionUsageCompletionTokensDetails acceptedPredictionTokens(@javax.annotation.Nullable Integer acceptedPredictionTokens) {
    
    this.acceptedPredictionTokens = acceptedPredictionTokens;
    return this;
  }

  /**
   * When using Predicted Outputs, the number of tokens in the prediction that appeared in the completion. 
   * @return acceptedPredictionTokens
   */
  @javax.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_ACCEPTED_PREDICTION_TOKENS)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public Integer getAcceptedPredictionTokens() {
    return acceptedPredictionTokens;
  }


  @JsonProperty(JSON_PROPERTY_ACCEPTED_PREDICTION_TOKENS)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setAcceptedPredictionTokens(@javax.annotation.Nullable Integer acceptedPredictionTokens) {
    this.acceptedPredictionTokens = acceptedPredictionTokens;
  }

  public CompletionUsageCompletionTokensDetails audioTokens(@javax.annotation.Nullable Integer audioTokens) {
    
    this.audioTokens = audioTokens;
    return this;
  }

  /**
   * Audio input tokens generated by the model.
   * @return audioTokens
   */
  @javax.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_AUDIO_TOKENS)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public Integer getAudioTokens() {
    return audioTokens;
  }


  @JsonProperty(JSON_PROPERTY_AUDIO_TOKENS)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setAudioTokens(@javax.annotation.Nullable Integer audioTokens) {
    this.audioTokens = audioTokens;
  }

  public CompletionUsageCompletionTokensDetails reasoningTokens(@javax.annotation.Nullable Integer reasoningTokens) {
    
    this.reasoningTokens = reasoningTokens;
    return this;
  }

  /**
   * Tokens generated by the model for reasoning.
   * @return reasoningTokens
   */
  @javax.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_REASONING_TOKENS)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public Integer getReasoningTokens() {
    return reasoningTokens;
  }


  @JsonProperty(JSON_PROPERTY_REASONING_TOKENS)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setReasoningTokens(@javax.annotation.Nullable Integer reasoningTokens) {
    this.reasoningTokens = reasoningTokens;
  }

  public CompletionUsageCompletionTokensDetails rejectedPredictionTokens(@javax.annotation.Nullable Integer rejectedPredictionTokens) {
    
    this.rejectedPredictionTokens = rejectedPredictionTokens;
    return this;
  }

  /**
   * When using Predicted Outputs, the number of tokens in the prediction that did not appear in the completion. However, like reasoning tokens, these tokens are still counted in the total completion tokens for purposes of billing, output, and context window limits. 
   * @return rejectedPredictionTokens
   */
  @javax.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_REJECTED_PREDICTION_TOKENS)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public Integer getRejectedPredictionTokens() {
    return rejectedPredictionTokens;
  }


  @JsonProperty(JSON_PROPERTY_REJECTED_PREDICTION_TOKENS)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setRejectedPredictionTokens(@javax.annotation.Nullable Integer rejectedPredictionTokens) {
    this.rejectedPredictionTokens = rejectedPredictionTokens;
  }

  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    CompletionUsageCompletionTokensDetails completionUsageCompletionTokensDetails = (CompletionUsageCompletionTokensDetails) o;
    return Objects.equals(this.acceptedPredictionTokens, completionUsageCompletionTokensDetails.acceptedPredictionTokens) &&
        Objects.equals(this.audioTokens, completionUsageCompletionTokensDetails.audioTokens) &&
        Objects.equals(this.reasoningTokens, completionUsageCompletionTokensDetails.reasoningTokens) &&
        Objects.equals(this.rejectedPredictionTokens, completionUsageCompletionTokensDetails.rejectedPredictionTokens);
  }

  @Override
  public int hashCode() {
    return Objects.hash(acceptedPredictionTokens, audioTokens, reasoningTokens, rejectedPredictionTokens);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class CompletionUsageCompletionTokensDetails {\n");
    sb.append("    acceptedPredictionTokens: ").append(toIndentedString(acceptedPredictionTokens)).append("\n");
    sb.append("    audioTokens: ").append(toIndentedString(audioTokens)).append("\n");
    sb.append("    reasoningTokens: ").append(toIndentedString(reasoningTokens)).append("\n");
    sb.append("    rejectedPredictionTokens: ").append(toIndentedString(rejectedPredictionTokens)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

  /**
   * Convert the instance into URL query string.
   *
   * @return URL query string
   */
  public String toUrlQueryString() {
    return toUrlQueryString(null);
  }

  /**
   * Convert the instance into URL query string.
   *
   * @param prefix prefix of the query string
   * @return URL query string
   */
  public String toUrlQueryString(String prefix) {
    String suffix = "";
    String containerSuffix = "";
    String containerPrefix = "";
    if (prefix == null) {
      // style=form, explode=true, e.g. /pet?name=cat&type=manx
      prefix = "";
    } else {
      // deepObject style e.g. /pet?id[name]=cat&id[type]=manx
      prefix = prefix + "[";
      suffix = "]";
      containerSuffix = "]";
      containerPrefix = "[";
    }

    StringJoiner joiner = new StringJoiner("&");

    // add `accepted_prediction_tokens` to the URL query string
    if (getAcceptedPredictionTokens() != null) {
      try {
        joiner.add(String.format("%saccepted_prediction_tokens%s=%s", prefix, suffix, URLEncoder.encode(String.valueOf(getAcceptedPredictionTokens()), "UTF-8").replaceAll("\\+", "%20")));
      } catch (UnsupportedEncodingException e) {
        // Should never happen, UTF-8 is always supported
        throw new RuntimeException(e);
      }
    }

    // add `audio_tokens` to the URL query string
    if (getAudioTokens() != null) {
      try {
        joiner.add(String.format("%saudio_tokens%s=%s", prefix, suffix, URLEncoder.encode(String.valueOf(getAudioTokens()), "UTF-8").replaceAll("\\+", "%20")));
      } catch (UnsupportedEncodingException e) {
        // Should never happen, UTF-8 is always supported
        throw new RuntimeException(e);
      }
    }

    // add `reasoning_tokens` to the URL query string
    if (getReasoningTokens() != null) {
      try {
        joiner.add(String.format("%sreasoning_tokens%s=%s", prefix, suffix, URLEncoder.encode(String.valueOf(getReasoningTokens()), "UTF-8").replaceAll("\\+", "%20")));
      } catch (UnsupportedEncodingException e) {
        // Should never happen, UTF-8 is always supported
        throw new RuntimeException(e);
      }
    }

    // add `rejected_prediction_tokens` to the URL query string
    if (getRejectedPredictionTokens() != null) {
      try {
        joiner.add(String.format("%srejected_prediction_tokens%s=%s", prefix, suffix, URLEncoder.encode(String.valueOf(getRejectedPredictionTokens()), "UTF-8").replaceAll("\\+", "%20")));
      } catch (UnsupportedEncodingException e) {
        // Should never happen, UTF-8 is always supported
        throw new RuntimeException(e);
      }
    }

    return joiner.toString();
  }

}


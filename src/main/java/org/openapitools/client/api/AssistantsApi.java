/*
 * OpenAI API
 * The OpenAI REST API. Please see https://platform.openai.com/docs/api-reference for more details.
 *
 * The version of the OpenAPI document: 2.3.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

package org.openapitools.client.api;

import com.fasterxml.jackson.core.type.TypeReference;

import org.openapitools.client.ApiException;
import org.openapitools.client.ApiClient;
import org.openapitools.client.BaseApi;
import org.openapitools.client.Configuration;
import org.openapitools.client.Pair;

import org.openapitools.client.model.AssistantObject;
import org.openapitools.client.model.CreateAssistantRequest;
import org.openapitools.client.model.CreateMessageRequest;
import org.openapitools.client.model.CreateRunRequest;
import org.openapitools.client.model.CreateThreadAndRunRequest;
import org.openapitools.client.model.CreateThreadRequest;
import org.openapitools.client.model.DeleteAssistantResponse;
import org.openapitools.client.model.DeleteMessageResponse;
import org.openapitools.client.model.DeleteThreadResponse;
import org.openapitools.client.model.ListAssistantsResponse;
import org.openapitools.client.model.ListMessagesResponse;
import org.openapitools.client.model.ListRunStepsResponse;
import org.openapitools.client.model.ListRunsResponse;
import org.openapitools.client.model.MessageObject;
import org.openapitools.client.model.ModifyAssistantRequest;
import org.openapitools.client.model.ModifyMessageRequest;
import org.openapitools.client.model.ModifyRunRequest;
import org.openapitools.client.model.ModifyThreadRequest;
import org.openapitools.client.model.RunObject;
import org.openapitools.client.model.RunStepObject;
import org.openapitools.client.model.SubmitToolOutputsRunRequest;
import org.openapitools.client.model.ThreadObject;


import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.StringJoiner;

@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2025-01-14T12:15:51.997600814-05:00[US/Eastern]", comments = "Generator version: 7.10.0")
public class AssistantsApi extends BaseApi {

  public AssistantsApi() {
    super(Configuration.getDefaultApiClient());
  }

  public AssistantsApi(ApiClient apiClient) {
    super(apiClient);
  }

  /**
   * Cancels a run that is &#x60;in_progress&#x60;.
   * 
   * @param threadId The ID of the thread to which this run belongs. (required)
   * @param runId The ID of the run to cancel. (required)
   * @return RunObject
   * @throws ApiException if fails to make API call
   */
  public RunObject cancelRun(String threadId, String runId) throws ApiException {
    return this.cancelRun(threadId, runId, Collections.emptyMap());
  }


  /**
   * Cancels a run that is &#x60;in_progress&#x60;.
   * 
   * @param threadId The ID of the thread to which this run belongs. (required)
   * @param runId The ID of the run to cancel. (required)
   * @param additionalHeaders additionalHeaders for this call
   * @return RunObject
   * @throws ApiException if fails to make API call
   */
  public RunObject cancelRun(String threadId, String runId, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = null;
    
    // verify the required parameter 'threadId' is set
    if (threadId == null) {
      throw new ApiException(400, "Missing the required parameter 'threadId' when calling cancelRun");
    }
    
    // verify the required parameter 'runId' is set
    if (runId == null) {
      throw new ApiException(400, "Missing the required parameter 'runId' when calling cancelRun");
    }
    
    // create path and map variables
    String localVarPath = "/threads/{thread_id}/runs/{run_id}/cancel"
      .replaceAll("\\{" + "thread_id" + "\\}", apiClient.escapeString(apiClient.parameterToString(threadId)))
      .replaceAll("\\{" + "run_id" + "\\}", apiClient.escapeString(apiClient.parameterToString(runId)));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] { "ApiKeyAuth" };

    TypeReference<RunObject> localVarReturnType = new TypeReference<RunObject>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "POST",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }

  /**
   * Create an assistant with a model and instructions.
   * 
   * @param createAssistantRequest  (required)
   * @return AssistantObject
   * @throws ApiException if fails to make API call
   */
  public AssistantObject createAssistant(CreateAssistantRequest createAssistantRequest) throws ApiException {
    return this.createAssistant(createAssistantRequest, Collections.emptyMap());
  }


  /**
   * Create an assistant with a model and instructions.
   * 
   * @param createAssistantRequest  (required)
   * @param additionalHeaders additionalHeaders for this call
   * @return AssistantObject
   * @throws ApiException if fails to make API call
   */
  public AssistantObject createAssistant(CreateAssistantRequest createAssistantRequest, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = createAssistantRequest;
    
    // verify the required parameter 'createAssistantRequest' is set
    if (createAssistantRequest == null) {
      throw new ApiException(400, "Missing the required parameter 'createAssistantRequest' when calling createAssistant");
    }
    
    // create path and map variables
    String localVarPath = "/assistants";

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      "application/json"
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] { "ApiKeyAuth" };

    TypeReference<AssistantObject> localVarReturnType = new TypeReference<AssistantObject>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "POST",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }

  /**
   * Create a message.
   * 
   * @param threadId The ID of the [thread](/docs/api-reference/threads) to create a message for. (required)
   * @param createMessageRequest  (required)
   * @return MessageObject
   * @throws ApiException if fails to make API call
   */
  public MessageObject createMessage(String threadId, CreateMessageRequest createMessageRequest) throws ApiException {
    return this.createMessage(threadId, createMessageRequest, Collections.emptyMap());
  }


  /**
   * Create a message.
   * 
   * @param threadId The ID of the [thread](/docs/api-reference/threads) to create a message for. (required)
   * @param createMessageRequest  (required)
   * @param additionalHeaders additionalHeaders for this call
   * @return MessageObject
   * @throws ApiException if fails to make API call
   */
  public MessageObject createMessage(String threadId, CreateMessageRequest createMessageRequest, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = createMessageRequest;
    
    // verify the required parameter 'threadId' is set
    if (threadId == null) {
      throw new ApiException(400, "Missing the required parameter 'threadId' when calling createMessage");
    }
    
    // verify the required parameter 'createMessageRequest' is set
    if (createMessageRequest == null) {
      throw new ApiException(400, "Missing the required parameter 'createMessageRequest' when calling createMessage");
    }
    
    // create path and map variables
    String localVarPath = "/threads/{thread_id}/messages"
      .replaceAll("\\{" + "thread_id" + "\\}", apiClient.escapeString(apiClient.parameterToString(threadId)));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      "application/json"
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] { "ApiKeyAuth" };

    TypeReference<MessageObject> localVarReturnType = new TypeReference<MessageObject>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "POST",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }

  /**
   * Create a run.
   * 
   * @param threadId The ID of the thread to run. (required)
   * @param createRunRequest  (required)
   * @param include A list of additional fields to include in the response. Currently the only supported value is &#x60;step_details.tool_calls[*].file_search.results[*].content&#x60; to fetch the file search result content.  See the [file search tool documentation](/docs/assistants/tools/file-search#customizing-file-search-settings) for more information.  (optional)
   * @return RunObject
   * @throws ApiException if fails to make API call
   */
  public RunObject createRun(String threadId, CreateRunRequest createRunRequest, List<String> include) throws ApiException {
    return this.createRun(threadId, createRunRequest, include, Collections.emptyMap());
  }


  /**
   * Create a run.
   * 
   * @param threadId The ID of the thread to run. (required)
   * @param createRunRequest  (required)
   * @param include A list of additional fields to include in the response. Currently the only supported value is &#x60;step_details.tool_calls[*].file_search.results[*].content&#x60; to fetch the file search result content.  See the [file search tool documentation](/docs/assistants/tools/file-search#customizing-file-search-settings) for more information.  (optional)
   * @param additionalHeaders additionalHeaders for this call
   * @return RunObject
   * @throws ApiException if fails to make API call
   */
  public RunObject createRun(String threadId, CreateRunRequest createRunRequest, List<String> include, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = createRunRequest;
    
    // verify the required parameter 'threadId' is set
    if (threadId == null) {
      throw new ApiException(400, "Missing the required parameter 'threadId' when calling createRun");
    }
    
    // verify the required parameter 'createRunRequest' is set
    if (createRunRequest == null) {
      throw new ApiException(400, "Missing the required parameter 'createRunRequest' when calling createRun");
    }
    
    // create path and map variables
    String localVarPath = "/threads/{thread_id}/runs"
      .replaceAll("\\{" + "thread_id" + "\\}", apiClient.escapeString(apiClient.parameterToString(threadId)));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    localVarCollectionQueryParams.addAll(apiClient.parameterToPairs("multi", "include[]", include));
    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      "application/json"
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] { "ApiKeyAuth" };

    TypeReference<RunObject> localVarReturnType = new TypeReference<RunObject>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "POST",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }

  /**
   * Create a thread.
   * 
   * @param createThreadRequest  (optional)
   * @return ThreadObject
   * @throws ApiException if fails to make API call
   */
  public ThreadObject createThread(CreateThreadRequest createThreadRequest) throws ApiException {
    return this.createThread(createThreadRequest, Collections.emptyMap());
  }


  /**
   * Create a thread.
   * 
   * @param createThreadRequest  (optional)
   * @param additionalHeaders additionalHeaders for this call
   * @return ThreadObject
   * @throws ApiException if fails to make API call
   */
  public ThreadObject createThread(CreateThreadRequest createThreadRequest, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = createThreadRequest;
    
    // create path and map variables
    String localVarPath = "/threads";

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      "application/json"
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] { "ApiKeyAuth" };

    TypeReference<ThreadObject> localVarReturnType = new TypeReference<ThreadObject>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "POST",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }

  /**
   * Create a thread and run it in one request.
   * 
   * @param createThreadAndRunRequest  (required)
   * @return RunObject
   * @throws ApiException if fails to make API call
   */
  public RunObject createThreadAndRun(CreateThreadAndRunRequest createThreadAndRunRequest) throws ApiException {
    return this.createThreadAndRun(createThreadAndRunRequest, Collections.emptyMap());
  }


  /**
   * Create a thread and run it in one request.
   * 
   * @param createThreadAndRunRequest  (required)
   * @param additionalHeaders additionalHeaders for this call
   * @return RunObject
   * @throws ApiException if fails to make API call
   */
  public RunObject createThreadAndRun(CreateThreadAndRunRequest createThreadAndRunRequest, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = createThreadAndRunRequest;
    
    // verify the required parameter 'createThreadAndRunRequest' is set
    if (createThreadAndRunRequest == null) {
      throw new ApiException(400, "Missing the required parameter 'createThreadAndRunRequest' when calling createThreadAndRun");
    }
    
    // create path and map variables
    String localVarPath = "/threads/runs";

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      "application/json"
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] { "ApiKeyAuth" };

    TypeReference<RunObject> localVarReturnType = new TypeReference<RunObject>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "POST",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }

  /**
   * Delete an assistant.
   * 
   * @param assistantId The ID of the assistant to delete. (required)
   * @return DeleteAssistantResponse
   * @throws ApiException if fails to make API call
   */
  public DeleteAssistantResponse deleteAssistant(String assistantId) throws ApiException {
    return this.deleteAssistant(assistantId, Collections.emptyMap());
  }


  /**
   * Delete an assistant.
   * 
   * @param assistantId The ID of the assistant to delete. (required)
   * @param additionalHeaders additionalHeaders for this call
   * @return DeleteAssistantResponse
   * @throws ApiException if fails to make API call
   */
  public DeleteAssistantResponse deleteAssistant(String assistantId, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = null;
    
    // verify the required parameter 'assistantId' is set
    if (assistantId == null) {
      throw new ApiException(400, "Missing the required parameter 'assistantId' when calling deleteAssistant");
    }
    
    // create path and map variables
    String localVarPath = "/assistants/{assistant_id}"
      .replaceAll("\\{" + "assistant_id" + "\\}", apiClient.escapeString(apiClient.parameterToString(assistantId)));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] { "ApiKeyAuth" };

    TypeReference<DeleteAssistantResponse> localVarReturnType = new TypeReference<DeleteAssistantResponse>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "DELETE",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }

  /**
   * Deletes a message.
   * 
   * @param threadId The ID of the thread to which this message belongs. (required)
   * @param messageId The ID of the message to delete. (required)
   * @return DeleteMessageResponse
   * @throws ApiException if fails to make API call
   */
  public DeleteMessageResponse deleteMessage(String threadId, String messageId) throws ApiException {
    return this.deleteMessage(threadId, messageId, Collections.emptyMap());
  }


  /**
   * Deletes a message.
   * 
   * @param threadId The ID of the thread to which this message belongs. (required)
   * @param messageId The ID of the message to delete. (required)
   * @param additionalHeaders additionalHeaders for this call
   * @return DeleteMessageResponse
   * @throws ApiException if fails to make API call
   */
  public DeleteMessageResponse deleteMessage(String threadId, String messageId, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = null;
    
    // verify the required parameter 'threadId' is set
    if (threadId == null) {
      throw new ApiException(400, "Missing the required parameter 'threadId' when calling deleteMessage");
    }
    
    // verify the required parameter 'messageId' is set
    if (messageId == null) {
      throw new ApiException(400, "Missing the required parameter 'messageId' when calling deleteMessage");
    }
    
    // create path and map variables
    String localVarPath = "/threads/{thread_id}/messages/{message_id}"
      .replaceAll("\\{" + "thread_id" + "\\}", apiClient.escapeString(apiClient.parameterToString(threadId)))
      .replaceAll("\\{" + "message_id" + "\\}", apiClient.escapeString(apiClient.parameterToString(messageId)));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] { "ApiKeyAuth" };

    TypeReference<DeleteMessageResponse> localVarReturnType = new TypeReference<DeleteMessageResponse>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "DELETE",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }

  /**
   * Delete a thread.
   * 
   * @param threadId The ID of the thread to delete. (required)
   * @return DeleteThreadResponse
   * @throws ApiException if fails to make API call
   */
  public DeleteThreadResponse deleteThread(String threadId) throws ApiException {
    return this.deleteThread(threadId, Collections.emptyMap());
  }


  /**
   * Delete a thread.
   * 
   * @param threadId The ID of the thread to delete. (required)
   * @param additionalHeaders additionalHeaders for this call
   * @return DeleteThreadResponse
   * @throws ApiException if fails to make API call
   */
  public DeleteThreadResponse deleteThread(String threadId, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = null;
    
    // verify the required parameter 'threadId' is set
    if (threadId == null) {
      throw new ApiException(400, "Missing the required parameter 'threadId' when calling deleteThread");
    }
    
    // create path and map variables
    String localVarPath = "/threads/{thread_id}"
      .replaceAll("\\{" + "thread_id" + "\\}", apiClient.escapeString(apiClient.parameterToString(threadId)));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] { "ApiKeyAuth" };

    TypeReference<DeleteThreadResponse> localVarReturnType = new TypeReference<DeleteThreadResponse>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "DELETE",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }

  /**
   * Retrieves an assistant.
   * 
   * @param assistantId The ID of the assistant to retrieve. (required)
   * @return AssistantObject
   * @throws ApiException if fails to make API call
   */
  public AssistantObject getAssistant(String assistantId) throws ApiException {
    return this.getAssistant(assistantId, Collections.emptyMap());
  }


  /**
   * Retrieves an assistant.
   * 
   * @param assistantId The ID of the assistant to retrieve. (required)
   * @param additionalHeaders additionalHeaders for this call
   * @return AssistantObject
   * @throws ApiException if fails to make API call
   */
  public AssistantObject getAssistant(String assistantId, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = null;
    
    // verify the required parameter 'assistantId' is set
    if (assistantId == null) {
      throw new ApiException(400, "Missing the required parameter 'assistantId' when calling getAssistant");
    }
    
    // create path and map variables
    String localVarPath = "/assistants/{assistant_id}"
      .replaceAll("\\{" + "assistant_id" + "\\}", apiClient.escapeString(apiClient.parameterToString(assistantId)));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] { "ApiKeyAuth" };

    TypeReference<AssistantObject> localVarReturnType = new TypeReference<AssistantObject>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "GET",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }

  /**
   * Retrieve a message.
   * 
   * @param threadId The ID of the [thread](/docs/api-reference/threads) to which this message belongs. (required)
   * @param messageId The ID of the message to retrieve. (required)
   * @return MessageObject
   * @throws ApiException if fails to make API call
   */
  public MessageObject getMessage(String threadId, String messageId) throws ApiException {
    return this.getMessage(threadId, messageId, Collections.emptyMap());
  }


  /**
   * Retrieve a message.
   * 
   * @param threadId The ID of the [thread](/docs/api-reference/threads) to which this message belongs. (required)
   * @param messageId The ID of the message to retrieve. (required)
   * @param additionalHeaders additionalHeaders for this call
   * @return MessageObject
   * @throws ApiException if fails to make API call
   */
  public MessageObject getMessage(String threadId, String messageId, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = null;
    
    // verify the required parameter 'threadId' is set
    if (threadId == null) {
      throw new ApiException(400, "Missing the required parameter 'threadId' when calling getMessage");
    }
    
    // verify the required parameter 'messageId' is set
    if (messageId == null) {
      throw new ApiException(400, "Missing the required parameter 'messageId' when calling getMessage");
    }
    
    // create path and map variables
    String localVarPath = "/threads/{thread_id}/messages/{message_id}"
      .replaceAll("\\{" + "thread_id" + "\\}", apiClient.escapeString(apiClient.parameterToString(threadId)))
      .replaceAll("\\{" + "message_id" + "\\}", apiClient.escapeString(apiClient.parameterToString(messageId)));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] { "ApiKeyAuth" };

    TypeReference<MessageObject> localVarReturnType = new TypeReference<MessageObject>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "GET",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }

  /**
   * Retrieves a run.
   * 
   * @param threadId The ID of the [thread](/docs/api-reference/threads) that was run. (required)
   * @param runId The ID of the run to retrieve. (required)
   * @return RunObject
   * @throws ApiException if fails to make API call
   */
  public RunObject getRun(String threadId, String runId) throws ApiException {
    return this.getRun(threadId, runId, Collections.emptyMap());
  }


  /**
   * Retrieves a run.
   * 
   * @param threadId The ID of the [thread](/docs/api-reference/threads) that was run. (required)
   * @param runId The ID of the run to retrieve. (required)
   * @param additionalHeaders additionalHeaders for this call
   * @return RunObject
   * @throws ApiException if fails to make API call
   */
  public RunObject getRun(String threadId, String runId, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = null;
    
    // verify the required parameter 'threadId' is set
    if (threadId == null) {
      throw new ApiException(400, "Missing the required parameter 'threadId' when calling getRun");
    }
    
    // verify the required parameter 'runId' is set
    if (runId == null) {
      throw new ApiException(400, "Missing the required parameter 'runId' when calling getRun");
    }
    
    // create path and map variables
    String localVarPath = "/threads/{thread_id}/runs/{run_id}"
      .replaceAll("\\{" + "thread_id" + "\\}", apiClient.escapeString(apiClient.parameterToString(threadId)))
      .replaceAll("\\{" + "run_id" + "\\}", apiClient.escapeString(apiClient.parameterToString(runId)));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] { "ApiKeyAuth" };

    TypeReference<RunObject> localVarReturnType = new TypeReference<RunObject>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "GET",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }

  /**
   * Retrieves a run step.
   * 
   * @param threadId The ID of the thread to which the run and run step belongs. (required)
   * @param runId The ID of the run to which the run step belongs. (required)
   * @param stepId The ID of the run step to retrieve. (required)
   * @param include A list of additional fields to include in the response. Currently the only supported value is &#x60;step_details.tool_calls[*].file_search.results[*].content&#x60; to fetch the file search result content.  See the [file search tool documentation](/docs/assistants/tools/file-search#customizing-file-search-settings) for more information.  (optional)
   * @return RunStepObject
   * @throws ApiException if fails to make API call
   */
  public RunStepObject getRunStep(String threadId, String runId, String stepId, List<String> include) throws ApiException {
    return this.getRunStep(threadId, runId, stepId, include, Collections.emptyMap());
  }


  /**
   * Retrieves a run step.
   * 
   * @param threadId The ID of the thread to which the run and run step belongs. (required)
   * @param runId The ID of the run to which the run step belongs. (required)
   * @param stepId The ID of the run step to retrieve. (required)
   * @param include A list of additional fields to include in the response. Currently the only supported value is &#x60;step_details.tool_calls[*].file_search.results[*].content&#x60; to fetch the file search result content.  See the [file search tool documentation](/docs/assistants/tools/file-search#customizing-file-search-settings) for more information.  (optional)
   * @param additionalHeaders additionalHeaders for this call
   * @return RunStepObject
   * @throws ApiException if fails to make API call
   */
  public RunStepObject getRunStep(String threadId, String runId, String stepId, List<String> include, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = null;
    
    // verify the required parameter 'threadId' is set
    if (threadId == null) {
      throw new ApiException(400, "Missing the required parameter 'threadId' when calling getRunStep");
    }
    
    // verify the required parameter 'runId' is set
    if (runId == null) {
      throw new ApiException(400, "Missing the required parameter 'runId' when calling getRunStep");
    }
    
    // verify the required parameter 'stepId' is set
    if (stepId == null) {
      throw new ApiException(400, "Missing the required parameter 'stepId' when calling getRunStep");
    }
    
    // create path and map variables
    String localVarPath = "/threads/{thread_id}/runs/{run_id}/steps/{step_id}"
      .replaceAll("\\{" + "thread_id" + "\\}", apiClient.escapeString(apiClient.parameterToString(threadId)))
      .replaceAll("\\{" + "run_id" + "\\}", apiClient.escapeString(apiClient.parameterToString(runId)))
      .replaceAll("\\{" + "step_id" + "\\}", apiClient.escapeString(apiClient.parameterToString(stepId)));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    localVarCollectionQueryParams.addAll(apiClient.parameterToPairs("multi", "include[]", include));
    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] { "ApiKeyAuth" };

    TypeReference<RunStepObject> localVarReturnType = new TypeReference<RunStepObject>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "GET",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }

  /**
   * Retrieves a thread.
   * 
   * @param threadId The ID of the thread to retrieve. (required)
   * @return ThreadObject
   * @throws ApiException if fails to make API call
   */
  public ThreadObject getThread(String threadId) throws ApiException {
    return this.getThread(threadId, Collections.emptyMap());
  }


  /**
   * Retrieves a thread.
   * 
   * @param threadId The ID of the thread to retrieve. (required)
   * @param additionalHeaders additionalHeaders for this call
   * @return ThreadObject
   * @throws ApiException if fails to make API call
   */
  public ThreadObject getThread(String threadId, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = null;
    
    // verify the required parameter 'threadId' is set
    if (threadId == null) {
      throw new ApiException(400, "Missing the required parameter 'threadId' when calling getThread");
    }
    
    // create path and map variables
    String localVarPath = "/threads/{thread_id}"
      .replaceAll("\\{" + "thread_id" + "\\}", apiClient.escapeString(apiClient.parameterToString(threadId)));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] { "ApiKeyAuth" };

    TypeReference<ThreadObject> localVarReturnType = new TypeReference<ThreadObject>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "GET",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }

  /**
   * Returns a list of assistants.
   * 
   * @param limit A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 20.  (optional, default to 20)
   * @param order Sort order by the &#x60;created_at&#x60; timestamp of the objects. &#x60;asc&#x60; for ascending order and &#x60;desc&#x60; for descending order.  (optional, default to desc)
   * @param after A cursor for use in pagination. &#x60;after&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include after&#x3D;obj_foo in order to fetch the next page of the list.  (optional)
   * @param before A cursor for use in pagination. &#x60;before&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with obj_foo, your subsequent call can include before&#x3D;obj_foo in order to fetch the previous page of the list.  (optional)
   * @return ListAssistantsResponse
   * @throws ApiException if fails to make API call
   */
  public ListAssistantsResponse listAssistants(Integer limit, String order, String after, String before) throws ApiException {
    return this.listAssistants(limit, order, after, before, Collections.emptyMap());
  }


  /**
   * Returns a list of assistants.
   * 
   * @param limit A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 20.  (optional, default to 20)
   * @param order Sort order by the &#x60;created_at&#x60; timestamp of the objects. &#x60;asc&#x60; for ascending order and &#x60;desc&#x60; for descending order.  (optional, default to desc)
   * @param after A cursor for use in pagination. &#x60;after&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include after&#x3D;obj_foo in order to fetch the next page of the list.  (optional)
   * @param before A cursor for use in pagination. &#x60;before&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with obj_foo, your subsequent call can include before&#x3D;obj_foo in order to fetch the previous page of the list.  (optional)
   * @param additionalHeaders additionalHeaders for this call
   * @return ListAssistantsResponse
   * @throws ApiException if fails to make API call
   */
  public ListAssistantsResponse listAssistants(Integer limit, String order, String after, String before, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = null;
    
    // create path and map variables
    String localVarPath = "/assistants";

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    localVarQueryParams.addAll(apiClient.parameterToPair("limit", limit));
    localVarQueryParams.addAll(apiClient.parameterToPair("order", order));
    localVarQueryParams.addAll(apiClient.parameterToPair("after", after));
    localVarQueryParams.addAll(apiClient.parameterToPair("before", before));
    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] { "ApiKeyAuth" };

    TypeReference<ListAssistantsResponse> localVarReturnType = new TypeReference<ListAssistantsResponse>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "GET",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }

  /**
   * Returns a list of messages for a given thread.
   * 
   * @param threadId The ID of the [thread](/docs/api-reference/threads) the messages belong to. (required)
   * @param limit A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 20.  (optional, default to 20)
   * @param order Sort order by the &#x60;created_at&#x60; timestamp of the objects. &#x60;asc&#x60; for ascending order and &#x60;desc&#x60; for descending order.  (optional, default to desc)
   * @param after A cursor for use in pagination. &#x60;after&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include after&#x3D;obj_foo in order to fetch the next page of the list.  (optional)
   * @param before A cursor for use in pagination. &#x60;before&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with obj_foo, your subsequent call can include before&#x3D;obj_foo in order to fetch the previous page of the list.  (optional)
   * @param runId Filter messages by the run ID that generated them.  (optional)
   * @return ListMessagesResponse
   * @throws ApiException if fails to make API call
   */
  public ListMessagesResponse listMessages(String threadId, Integer limit, String order, String after, String before, String runId) throws ApiException {
    return this.listMessages(threadId, limit, order, after, before, runId, Collections.emptyMap());
  }


  /**
   * Returns a list of messages for a given thread.
   * 
   * @param threadId The ID of the [thread](/docs/api-reference/threads) the messages belong to. (required)
   * @param limit A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 20.  (optional, default to 20)
   * @param order Sort order by the &#x60;created_at&#x60; timestamp of the objects. &#x60;asc&#x60; for ascending order and &#x60;desc&#x60; for descending order.  (optional, default to desc)
   * @param after A cursor for use in pagination. &#x60;after&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include after&#x3D;obj_foo in order to fetch the next page of the list.  (optional)
   * @param before A cursor for use in pagination. &#x60;before&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with obj_foo, your subsequent call can include before&#x3D;obj_foo in order to fetch the previous page of the list.  (optional)
   * @param runId Filter messages by the run ID that generated them.  (optional)
   * @param additionalHeaders additionalHeaders for this call
   * @return ListMessagesResponse
   * @throws ApiException if fails to make API call
   */
  public ListMessagesResponse listMessages(String threadId, Integer limit, String order, String after, String before, String runId, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = null;
    
    // verify the required parameter 'threadId' is set
    if (threadId == null) {
      throw new ApiException(400, "Missing the required parameter 'threadId' when calling listMessages");
    }
    
    // create path and map variables
    String localVarPath = "/threads/{thread_id}/messages"
      .replaceAll("\\{" + "thread_id" + "\\}", apiClient.escapeString(apiClient.parameterToString(threadId)));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    localVarQueryParams.addAll(apiClient.parameterToPair("limit", limit));
    localVarQueryParams.addAll(apiClient.parameterToPair("order", order));
    localVarQueryParams.addAll(apiClient.parameterToPair("after", after));
    localVarQueryParams.addAll(apiClient.parameterToPair("before", before));
    localVarQueryParams.addAll(apiClient.parameterToPair("run_id", runId));
    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] { "ApiKeyAuth" };

    TypeReference<ListMessagesResponse> localVarReturnType = new TypeReference<ListMessagesResponse>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "GET",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }

  /**
   * Returns a list of run steps belonging to a run.
   * 
   * @param threadId The ID of the thread the run and run steps belong to. (required)
   * @param runId The ID of the run the run steps belong to. (required)
   * @param limit A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 20.  (optional, default to 20)
   * @param order Sort order by the &#x60;created_at&#x60; timestamp of the objects. &#x60;asc&#x60; for ascending order and &#x60;desc&#x60; for descending order.  (optional, default to desc)
   * @param after A cursor for use in pagination. &#x60;after&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include after&#x3D;obj_foo in order to fetch the next page of the list.  (optional)
   * @param before A cursor for use in pagination. &#x60;before&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with obj_foo, your subsequent call can include before&#x3D;obj_foo in order to fetch the previous page of the list.  (optional)
   * @param include A list of additional fields to include in the response. Currently the only supported value is &#x60;step_details.tool_calls[*].file_search.results[*].content&#x60; to fetch the file search result content.  See the [file search tool documentation](/docs/assistants/tools/file-search#customizing-file-search-settings) for more information.  (optional)
   * @return ListRunStepsResponse
   * @throws ApiException if fails to make API call
   */
  public ListRunStepsResponse listRunSteps(String threadId, String runId, Integer limit, String order, String after, String before, List<String> include) throws ApiException {
    return this.listRunSteps(threadId, runId, limit, order, after, before, include, Collections.emptyMap());
  }


  /**
   * Returns a list of run steps belonging to a run.
   * 
   * @param threadId The ID of the thread the run and run steps belong to. (required)
   * @param runId The ID of the run the run steps belong to. (required)
   * @param limit A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 20.  (optional, default to 20)
   * @param order Sort order by the &#x60;created_at&#x60; timestamp of the objects. &#x60;asc&#x60; for ascending order and &#x60;desc&#x60; for descending order.  (optional, default to desc)
   * @param after A cursor for use in pagination. &#x60;after&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include after&#x3D;obj_foo in order to fetch the next page of the list.  (optional)
   * @param before A cursor for use in pagination. &#x60;before&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with obj_foo, your subsequent call can include before&#x3D;obj_foo in order to fetch the previous page of the list.  (optional)
   * @param include A list of additional fields to include in the response. Currently the only supported value is &#x60;step_details.tool_calls[*].file_search.results[*].content&#x60; to fetch the file search result content.  See the [file search tool documentation](/docs/assistants/tools/file-search#customizing-file-search-settings) for more information.  (optional)
   * @param additionalHeaders additionalHeaders for this call
   * @return ListRunStepsResponse
   * @throws ApiException if fails to make API call
   */
  public ListRunStepsResponse listRunSteps(String threadId, String runId, Integer limit, String order, String after, String before, List<String> include, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = null;
    
    // verify the required parameter 'threadId' is set
    if (threadId == null) {
      throw new ApiException(400, "Missing the required parameter 'threadId' when calling listRunSteps");
    }
    
    // verify the required parameter 'runId' is set
    if (runId == null) {
      throw new ApiException(400, "Missing the required parameter 'runId' when calling listRunSteps");
    }
    
    // create path and map variables
    String localVarPath = "/threads/{thread_id}/runs/{run_id}/steps"
      .replaceAll("\\{" + "thread_id" + "\\}", apiClient.escapeString(apiClient.parameterToString(threadId)))
      .replaceAll("\\{" + "run_id" + "\\}", apiClient.escapeString(apiClient.parameterToString(runId)));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    localVarQueryParams.addAll(apiClient.parameterToPair("limit", limit));
    localVarQueryParams.addAll(apiClient.parameterToPair("order", order));
    localVarQueryParams.addAll(apiClient.parameterToPair("after", after));
    localVarQueryParams.addAll(apiClient.parameterToPair("before", before));
    localVarCollectionQueryParams.addAll(apiClient.parameterToPairs("multi", "include[]", include));
    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] { "ApiKeyAuth" };

    TypeReference<ListRunStepsResponse> localVarReturnType = new TypeReference<ListRunStepsResponse>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "GET",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }

  /**
   * Returns a list of runs belonging to a thread.
   * 
   * @param threadId The ID of the thread the run belongs to. (required)
   * @param limit A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 20.  (optional, default to 20)
   * @param order Sort order by the &#x60;created_at&#x60; timestamp of the objects. &#x60;asc&#x60; for ascending order and &#x60;desc&#x60; for descending order.  (optional, default to desc)
   * @param after A cursor for use in pagination. &#x60;after&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include after&#x3D;obj_foo in order to fetch the next page of the list.  (optional)
   * @param before A cursor for use in pagination. &#x60;before&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with obj_foo, your subsequent call can include before&#x3D;obj_foo in order to fetch the previous page of the list.  (optional)
   * @return ListRunsResponse
   * @throws ApiException if fails to make API call
   */
  public ListRunsResponse listRuns(String threadId, Integer limit, String order, String after, String before) throws ApiException {
    return this.listRuns(threadId, limit, order, after, before, Collections.emptyMap());
  }


  /**
   * Returns a list of runs belonging to a thread.
   * 
   * @param threadId The ID of the thread the run belongs to. (required)
   * @param limit A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 20.  (optional, default to 20)
   * @param order Sort order by the &#x60;created_at&#x60; timestamp of the objects. &#x60;asc&#x60; for ascending order and &#x60;desc&#x60; for descending order.  (optional, default to desc)
   * @param after A cursor for use in pagination. &#x60;after&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include after&#x3D;obj_foo in order to fetch the next page of the list.  (optional)
   * @param before A cursor for use in pagination. &#x60;before&#x60; is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with obj_foo, your subsequent call can include before&#x3D;obj_foo in order to fetch the previous page of the list.  (optional)
   * @param additionalHeaders additionalHeaders for this call
   * @return ListRunsResponse
   * @throws ApiException if fails to make API call
   */
  public ListRunsResponse listRuns(String threadId, Integer limit, String order, String after, String before, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = null;
    
    // verify the required parameter 'threadId' is set
    if (threadId == null) {
      throw new ApiException(400, "Missing the required parameter 'threadId' when calling listRuns");
    }
    
    // create path and map variables
    String localVarPath = "/threads/{thread_id}/runs"
      .replaceAll("\\{" + "thread_id" + "\\}", apiClient.escapeString(apiClient.parameterToString(threadId)));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    localVarQueryParams.addAll(apiClient.parameterToPair("limit", limit));
    localVarQueryParams.addAll(apiClient.parameterToPair("order", order));
    localVarQueryParams.addAll(apiClient.parameterToPair("after", after));
    localVarQueryParams.addAll(apiClient.parameterToPair("before", before));
    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] { "ApiKeyAuth" };

    TypeReference<ListRunsResponse> localVarReturnType = new TypeReference<ListRunsResponse>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "GET",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }

  /**
   * Modifies an assistant.
   * 
   * @param assistantId The ID of the assistant to modify. (required)
   * @param modifyAssistantRequest  (required)
   * @return AssistantObject
   * @throws ApiException if fails to make API call
   */
  public AssistantObject modifyAssistant(String assistantId, ModifyAssistantRequest modifyAssistantRequest) throws ApiException {
    return this.modifyAssistant(assistantId, modifyAssistantRequest, Collections.emptyMap());
  }


  /**
   * Modifies an assistant.
   * 
   * @param assistantId The ID of the assistant to modify. (required)
   * @param modifyAssistantRequest  (required)
   * @param additionalHeaders additionalHeaders for this call
   * @return AssistantObject
   * @throws ApiException if fails to make API call
   */
  public AssistantObject modifyAssistant(String assistantId, ModifyAssistantRequest modifyAssistantRequest, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = modifyAssistantRequest;
    
    // verify the required parameter 'assistantId' is set
    if (assistantId == null) {
      throw new ApiException(400, "Missing the required parameter 'assistantId' when calling modifyAssistant");
    }
    
    // verify the required parameter 'modifyAssistantRequest' is set
    if (modifyAssistantRequest == null) {
      throw new ApiException(400, "Missing the required parameter 'modifyAssistantRequest' when calling modifyAssistant");
    }
    
    // create path and map variables
    String localVarPath = "/assistants/{assistant_id}"
      .replaceAll("\\{" + "assistant_id" + "\\}", apiClient.escapeString(apiClient.parameterToString(assistantId)));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      "application/json"
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] { "ApiKeyAuth" };

    TypeReference<AssistantObject> localVarReturnType = new TypeReference<AssistantObject>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "POST",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }

  /**
   * Modifies a message.
   * 
   * @param threadId The ID of the thread to which this message belongs. (required)
   * @param messageId The ID of the message to modify. (required)
   * @param modifyMessageRequest  (required)
   * @return MessageObject
   * @throws ApiException if fails to make API call
   */
  public MessageObject modifyMessage(String threadId, String messageId, ModifyMessageRequest modifyMessageRequest) throws ApiException {
    return this.modifyMessage(threadId, messageId, modifyMessageRequest, Collections.emptyMap());
  }


  /**
   * Modifies a message.
   * 
   * @param threadId The ID of the thread to which this message belongs. (required)
   * @param messageId The ID of the message to modify. (required)
   * @param modifyMessageRequest  (required)
   * @param additionalHeaders additionalHeaders for this call
   * @return MessageObject
   * @throws ApiException if fails to make API call
   */
  public MessageObject modifyMessage(String threadId, String messageId, ModifyMessageRequest modifyMessageRequest, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = modifyMessageRequest;
    
    // verify the required parameter 'threadId' is set
    if (threadId == null) {
      throw new ApiException(400, "Missing the required parameter 'threadId' when calling modifyMessage");
    }
    
    // verify the required parameter 'messageId' is set
    if (messageId == null) {
      throw new ApiException(400, "Missing the required parameter 'messageId' when calling modifyMessage");
    }
    
    // verify the required parameter 'modifyMessageRequest' is set
    if (modifyMessageRequest == null) {
      throw new ApiException(400, "Missing the required parameter 'modifyMessageRequest' when calling modifyMessage");
    }
    
    // create path and map variables
    String localVarPath = "/threads/{thread_id}/messages/{message_id}"
      .replaceAll("\\{" + "thread_id" + "\\}", apiClient.escapeString(apiClient.parameterToString(threadId)))
      .replaceAll("\\{" + "message_id" + "\\}", apiClient.escapeString(apiClient.parameterToString(messageId)));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      "application/json"
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] { "ApiKeyAuth" };

    TypeReference<MessageObject> localVarReturnType = new TypeReference<MessageObject>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "POST",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }

  /**
   * Modifies a run.
   * 
   * @param threadId The ID of the [thread](/docs/api-reference/threads) that was run. (required)
   * @param runId The ID of the run to modify. (required)
   * @param modifyRunRequest  (required)
   * @return RunObject
   * @throws ApiException if fails to make API call
   */
  public RunObject modifyRun(String threadId, String runId, ModifyRunRequest modifyRunRequest) throws ApiException {
    return this.modifyRun(threadId, runId, modifyRunRequest, Collections.emptyMap());
  }


  /**
   * Modifies a run.
   * 
   * @param threadId The ID of the [thread](/docs/api-reference/threads) that was run. (required)
   * @param runId The ID of the run to modify. (required)
   * @param modifyRunRequest  (required)
   * @param additionalHeaders additionalHeaders for this call
   * @return RunObject
   * @throws ApiException if fails to make API call
   */
  public RunObject modifyRun(String threadId, String runId, ModifyRunRequest modifyRunRequest, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = modifyRunRequest;
    
    // verify the required parameter 'threadId' is set
    if (threadId == null) {
      throw new ApiException(400, "Missing the required parameter 'threadId' when calling modifyRun");
    }
    
    // verify the required parameter 'runId' is set
    if (runId == null) {
      throw new ApiException(400, "Missing the required parameter 'runId' when calling modifyRun");
    }
    
    // verify the required parameter 'modifyRunRequest' is set
    if (modifyRunRequest == null) {
      throw new ApiException(400, "Missing the required parameter 'modifyRunRequest' when calling modifyRun");
    }
    
    // create path and map variables
    String localVarPath = "/threads/{thread_id}/runs/{run_id}"
      .replaceAll("\\{" + "thread_id" + "\\}", apiClient.escapeString(apiClient.parameterToString(threadId)))
      .replaceAll("\\{" + "run_id" + "\\}", apiClient.escapeString(apiClient.parameterToString(runId)));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      "application/json"
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] { "ApiKeyAuth" };

    TypeReference<RunObject> localVarReturnType = new TypeReference<RunObject>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "POST",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }

  /**
   * Modifies a thread.
   * 
   * @param threadId The ID of the thread to modify. Only the &#x60;metadata&#x60; can be modified. (required)
   * @param modifyThreadRequest  (required)
   * @return ThreadObject
   * @throws ApiException if fails to make API call
   */
  public ThreadObject modifyThread(String threadId, ModifyThreadRequest modifyThreadRequest) throws ApiException {
    return this.modifyThread(threadId, modifyThreadRequest, Collections.emptyMap());
  }


  /**
   * Modifies a thread.
   * 
   * @param threadId The ID of the thread to modify. Only the &#x60;metadata&#x60; can be modified. (required)
   * @param modifyThreadRequest  (required)
   * @param additionalHeaders additionalHeaders for this call
   * @return ThreadObject
   * @throws ApiException if fails to make API call
   */
  public ThreadObject modifyThread(String threadId, ModifyThreadRequest modifyThreadRequest, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = modifyThreadRequest;
    
    // verify the required parameter 'threadId' is set
    if (threadId == null) {
      throw new ApiException(400, "Missing the required parameter 'threadId' when calling modifyThread");
    }
    
    // verify the required parameter 'modifyThreadRequest' is set
    if (modifyThreadRequest == null) {
      throw new ApiException(400, "Missing the required parameter 'modifyThreadRequest' when calling modifyThread");
    }
    
    // create path and map variables
    String localVarPath = "/threads/{thread_id}"
      .replaceAll("\\{" + "thread_id" + "\\}", apiClient.escapeString(apiClient.parameterToString(threadId)));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      "application/json"
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] { "ApiKeyAuth" };

    TypeReference<ThreadObject> localVarReturnType = new TypeReference<ThreadObject>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "POST",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }

  /**
   * When a run has the &#x60;status: \&quot;requires_action\&quot;&#x60; and &#x60;required_action.type&#x60; is &#x60;submit_tool_outputs&#x60;, this endpoint can be used to submit the outputs from the tool calls once they&#39;re all completed. All outputs must be submitted in a single request. 
   * 
   * @param threadId The ID of the [thread](/docs/api-reference/threads) to which this run belongs. (required)
   * @param runId The ID of the run that requires the tool output submission. (required)
   * @param submitToolOutputsRunRequest  (required)
   * @return RunObject
   * @throws ApiException if fails to make API call
   */
  public RunObject submitToolOuputsToRun(String threadId, String runId, SubmitToolOutputsRunRequest submitToolOutputsRunRequest) throws ApiException {
    return this.submitToolOuputsToRun(threadId, runId, submitToolOutputsRunRequest, Collections.emptyMap());
  }


  /**
   * When a run has the &#x60;status: \&quot;requires_action\&quot;&#x60; and &#x60;required_action.type&#x60; is &#x60;submit_tool_outputs&#x60;, this endpoint can be used to submit the outputs from the tool calls once they&#39;re all completed. All outputs must be submitted in a single request. 
   * 
   * @param threadId The ID of the [thread](/docs/api-reference/threads) to which this run belongs. (required)
   * @param runId The ID of the run that requires the tool output submission. (required)
   * @param submitToolOutputsRunRequest  (required)
   * @param additionalHeaders additionalHeaders for this call
   * @return RunObject
   * @throws ApiException if fails to make API call
   */
  public RunObject submitToolOuputsToRun(String threadId, String runId, SubmitToolOutputsRunRequest submitToolOutputsRunRequest, Map<String, String> additionalHeaders) throws ApiException {
    Object localVarPostBody = submitToolOutputsRunRequest;
    
    // verify the required parameter 'threadId' is set
    if (threadId == null) {
      throw new ApiException(400, "Missing the required parameter 'threadId' when calling submitToolOuputsToRun");
    }
    
    // verify the required parameter 'runId' is set
    if (runId == null) {
      throw new ApiException(400, "Missing the required parameter 'runId' when calling submitToolOuputsToRun");
    }
    
    // verify the required parameter 'submitToolOutputsRunRequest' is set
    if (submitToolOutputsRunRequest == null) {
      throw new ApiException(400, "Missing the required parameter 'submitToolOutputsRunRequest' when calling submitToolOuputsToRun");
    }
    
    // create path and map variables
    String localVarPath = "/threads/{thread_id}/runs/{run_id}/submit_tool_outputs"
      .replaceAll("\\{" + "thread_id" + "\\}", apiClient.escapeString(apiClient.parameterToString(threadId)))
      .replaceAll("\\{" + "run_id" + "\\}", apiClient.escapeString(apiClient.parameterToString(runId)));

    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    
    localVarHeaderParams.putAll(additionalHeaders);

    
    
    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      "application/json"
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] { "ApiKeyAuth" };

    TypeReference<RunObject> localVarReturnType = new TypeReference<RunObject>() {};
    return apiClient.invokeAPI(
        localVarPath,
        "POST",
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        localVarPostBody,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        localVarReturnType
    );
  }

  @Override
  public <T> T invokeAPI(String url, String method, Object request, TypeReference<T> returnType, Map<String, String> additionalHeaders) throws ApiException {
    String localVarPath = url.replace(apiClient.getBaseURL(), "");
    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    List<Pair> localVarQueryParams = new ArrayList<Pair>();
    List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
    Map<String, String> localVarHeaderParams = new HashMap<String, String>();
    Map<String, String> localVarCookieParams = new HashMap<String, String>();
    Map<String, Object> localVarFormParams = new HashMap<String, Object>();

    localVarHeaderParams.putAll(additionalHeaders);

    final String[] localVarAccepts = {
      "application/json"
    };
    final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);

    final String[] localVarContentTypes = {
      "application/json"
    };
    final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);

    String[] localVarAuthNames = new String[] { "ApiKeyAuth" };

    return apiClient.invokeAPI(
      localVarPath,
        method,
        localVarQueryParams,
        localVarCollectionQueryParams,
        localVarQueryStringJoiner.toString(),
        request,
        localVarHeaderParams,
        localVarCookieParams,
        localVarFormParams,
        localVarAccept,
        localVarContentType,
        localVarAuthNames,
        returnType
    );
  }
}
